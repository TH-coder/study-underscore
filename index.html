<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // const arr = [1, 2, 3, 4]

        // console.log(arr.slice(0, 100));

        // var fibonacci = memoize(function (n) {
        //     return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
        // });

        // function memoize(fun, handler) {

        //     const memory = function (key) {
        //         key = handler == null ? key : handler(key)
        //         if (!memory.cache.hasOwnProperty(key)) {
        //             memory.cache[key] = fun.call(this, key)
        //         }
        //         return memory.cache[key]
        //     }

        //     memory.cache = {}
        //     return memory
        // }

        // var hasher = function () {
        //     var n = arguments[0];
        //     return n + "max";
        // }

        // //这个数列从第3项开始,每一项都等于前两项之和.
        // //1 1  2  3 5 8 13 21 34 .....
        // var fibonacci = memoize(function (n) {
        //     return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
        // });
        // console.log(fibonacci(10000));

        //要在underscore把_赋值到全局变量的_之前先保存之前的_变量的内容
        // var preUnderscore = root._;

        //调用noConflict,就会把之前的_变量的内容放回全局变量中去,就可以直接通过_访问之前的内容了
        // _.noConflict = function () {
        //     root._ = preUnderscore;
        //     return this;
        // };

        // function template(str) {
        //     const ex = /<%=([\d\D]+?)%>|<%-([\d\D]+?)%>|<%([\d\D]+?)%>/g
        //     str.replace(ex, function (match, a, b, c) {
        //         console.log(match);
        //         console.log(a);
        //         console.log(b);
        //         console.log(c);
        //     })
        // }

        // template('<%= name %>')

        // const fnStr = 'function(a){console.log(a)}'
        // const fn = new Function('return '+fnStr)()
        // fn(2)
        // const name = new type(arguments);


        function fn(require, exports, module) {
            /* require("c.js")  */
            var age = "30";
            var b = require("b.js");
            exports.age = age;

            /* */
        }

        var str = fn.toString();

        //加了一个正则去除掉/* */注释,这里用的是?懒惰模式,即使有多个/* */也不会影响
        var REMOVECOMMENTS_RE = /\/\*[\s\S]*?\*\//g
        str = str.replace(/\/\*[\s\S]*?\*\//g, '')

        var REQUIRE_RE = /\brequire\s*\(\s*(["'])(.+?)\1\s*\)/g;

        str.replace(REQUIRE_RE, function (context, m1, m2) {
            console.log(m2)  // => c.js  b.js
        })

    </script>
</body>

</html>